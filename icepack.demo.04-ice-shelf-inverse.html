

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Inverse problems &mdash; icepack 0.0.3 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Ice streams, once more" href="icepack.demo.05-hybrid-ice-stream.html" />
    <link rel="prev" title="Synthetic ice stream" href="icepack.demo.03-synthetic-ice-stream.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> icepack
          

          
          </a>

          
            
            
              <div class="version">
                0.0.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="reading.html">Reading</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="icepack.demo.00-meshes-functions.html">Meshes, functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="icepack.demo.01-synthetic-ice-shelf.html">Synthetic ice shelf</a></li>
<li class="toctree-l1"><a class="reference internal" href="icepack.demo.02-larsen-ice-shelf.html">Larsen Ice Shelf</a></li>
<li class="toctree-l1"><a class="reference internal" href="icepack.demo.03-synthetic-ice-stream.html">Synthetic ice stream</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Inverse problems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#input-data">Input data</a></li>
<li class="toctree-l2"><a class="reference internal" href="#inferring-the-fluidity">Inferring the fluidity</a></li>
<li class="toctree-l2"><a class="reference internal" href="#analysis">Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="#conclusion">Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="icepack.demo.05-hybrid-ice-stream.html">Ice streams, once more</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="testing.html">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="design.html">Design</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="modules.html">icepack</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">icepack</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Inverse problems</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/icepack.demo.04-ice-shelf-inverse.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">matplotlib</span> inline
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">firedrake</span>
<span class="kn">import</span> <span class="nn">icepack</span><span class="o">,</span> <span class="nn">icepack.plot</span><span class="o">,</span> <span class="nn">icepack.models</span>
</pre></div>
</div>
<div class="section" id="inverse-problems">
<h1>Inverse problems<a class="headerlink" href="#inverse-problems" title="Permalink to this headline">¶</a></h1>
<p>In this demo, we’ll revisit the Larsen Ice Shelf. This time, we’re going
to estimate the fluidity coefficient <span class="math notranslate nohighlight">\(A\)</span> in Glen’s flow law</p>
<div class="math notranslate nohighlight">
\[\dot\varepsilon = A\tau^3\]</div>
<p>from observational data. In the previous demos, we’ve come up with some
value of the fluidity coefficient and computed a velocity field by
solving an elliptic partial differential equation. The fluidity
coefficient is roughly a known function of the ice temperature, together
with some fudge factors for crystal fabric or large-scale damage, so we
know an approximate range of values that it could take. Nonetheless, we
don’t have large-scale measurements of the fluidity coefficient from
remote sensing like we do for ice velocity and thickness.</p>
<p>Instead, we can try to come up with a value of <span class="math notranslate nohighlight">\(A\)</span> that gives a
velocity field closest to what we observed. This idea can be turned into
a constrained optimization problem. The quantity we wish to optimize is
the misfit between the computed velocity <span class="math notranslate nohighlight">\(u\)</span> and the observed
velocity <span class="math notranslate nohighlight">\(u^o\)</span>:</p>
<div class="math notranslate nohighlight">
\[E(u) = \frac{1}{2}\int_\Omega\left(\frac{u - u^o}{\sigma}\right)^2dx,\]</div>
<p>where <span class="math notranslate nohighlight">\(\sigma\)</span> are the standard deviations of the measurements.</p>
<p>One constraint is that the fluidity field has to be positive. Inequality
constraints can require substantially more sophisticated numerical
methods. To avoid this problem, we’ll cheat our way out by
reparameterizing <span class="math notranslate nohighlight">\(A\)</span> in terms of a new variable <span class="math notranslate nohighlight">\(\theta\)</span>:</p>
<div class="math notranslate nohighlight">
\[A = A_0e^{-\theta/n},\]</div>
<p>where <span class="math notranslate nohighlight">\(n\)</span> is the Glen flow law exponent. No matter the value of
<span class="math notranslate nohighlight">\(\theta\)</span>, <span class="math notranslate nohighlight">\(A\)</span> is always positive. To make this change, we’ll
give the <code class="docutils literal notranslate"><span class="pre">IceShelf</span></code> object our own custom-made function for
calculating the viscous part of the action functional, just like we did
for the friction in the last demo.</p>
<p>In addition to minimizing the misfit, we also want to have a relatively
smooth value of the parameter field <span class="math notranslate nohighlight">\(\theta\)</span>. The regularization
functional <span class="math notranslate nohighlight">\(R\)</span> is included to penalize oscillations over a given
length scale <span class="math notranslate nohighlight">\(L\)</span>:</p>
<div class="math notranslate nohighlight">
\[R(\theta) = \frac{L^2}{2}\int_\Omega|\nabla \theta|^2dx.\]</div>
<p>Finally, let <span class="math notranslate nohighlight">\(F(u, \theta)\)</span> be the weak form of the shallow shelf
equations, again using the new parameter <span class="math notranslate nohighlight">\(\theta\)</span> instead of the
fluidity <span class="math notranslate nohighlight">\(A\)</span>. The physics constraint for our problem is that
<span class="math notranslate nohighlight">\(F(u, \theta) = 0\)</span>. We can enforce this constraint by introducing
the Lagrange multiplier <span class="math notranslate nohighlight">\(\lambda\)</span>, in which case the combined
objective functional is</p>
<div class="math notranslate nohighlight">
\[J(u, \theta; \lambda) = E(u) + R(\theta) + \langle F(u, \theta), \lambda\rangle.\]</div>
<p>We can calculate the derivative of this functional with respect to
<span class="math notranslate nohighlight">\(\theta\)</span> by using the <em>adjoint method</em>. We can then use a descent
method to iterate towards a critical point, which is hopefully close to
the true value of the fluidity coefficient.</p>
<div class="section" id="input-data">
<h2>Input data<a class="headerlink" href="#input-data" title="Permalink to this headline">¶</a></h2>
<p>The input data are just as in the previous demo for the Larsen Ice
Shelf, but we also need to use the error estimates for the velocities.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">data_directory</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;ICEPACK_DATA&#39;</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mesh</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">Mesh</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_directory</span><span class="p">,</span> <span class="s2">&quot;meshes/larsen/larsen.msh&quot;</span><span class="p">))</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">axes</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;meters&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">triplot</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/icepack.demo.04-ice-shelf-inverse_4_0.png" src="_images/icepack.demo.04-ice-shelf-inverse_4_0.png" />
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">icepack.grid</span> <span class="k">import</span> <span class="n">arcinfo</span><span class="p">,</span> <span class="n">GridData</span>
<span class="n">thickness</span> <span class="o">=</span> <span class="n">arcinfo</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_directory</span><span class="p">,</span> <span class="s2">&quot;bedmap2/larsen-h.txt&quot;</span><span class="p">))</span>
<span class="n">vx</span> <span class="o">=</span> <span class="n">arcinfo</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_directory</span><span class="p">,</span> <span class="s2">&quot;measures_antarctica/larsen-vx.txt&quot;</span><span class="p">))</span>
<span class="n">vy</span> <span class="o">=</span> <span class="n">arcinfo</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_directory</span><span class="p">,</span> <span class="s2">&quot;measures_antarctica/larsen-vy.txt&quot;</span><span class="p">))</span>
<span class="n">stdx</span> <span class="o">=</span> <span class="n">arcinfo</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_directory</span><span class="p">,</span> <span class="s2">&quot;measures_antarctica/larsen-stdx.txt&quot;</span><span class="p">))</span>
<span class="n">stdy</span> <span class="o">=</span> <span class="n">arcinfo</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_directory</span><span class="p">,</span> <span class="s2">&quot;measures_antarctica/larsen-stdy.txt&quot;</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">preprocess</span> <span class="k">import</span> <span class="n">preprocess</span>
<span class="n">thickness</span> <span class="o">=</span> <span class="n">preprocess</span><span class="p">(</span><span class="n">thickness</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">degree</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">Q</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;CG&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;CG&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>

<span class="n">h</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">thickness</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
<span class="n">u_obs</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">interpolate</span><span class="p">((</span><span class="n">vx</span><span class="p">,</span> <span class="n">vy</span><span class="p">),</span> <span class="n">V</span><span class="p">)</span>
<span class="n">σx</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">stdx</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
<span class="n">σy</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">stdy</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
</pre></div>
</div>
<p>Here we’ll plot the velocity errors. You can see from the stripey
pattern that they depend on the particular swath from the observational
platform.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">σ</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">firedrake</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">σx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">σy</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">Q</span><span class="p">)</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">contours</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">tricontourf</span><span class="p">(</span><span class="n">σ</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">contours</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/icepack.demo.04-ice-shelf-inverse_9_0.png" src="_images/icepack.demo.04-ice-shelf-inverse_9_0.png" />
<p>We need to make an initial guess for the fluidity parameter. In this
case, we’ll use the same value as in the second demo – a constant
fluidity assuming a temperature of <span class="math notranslate nohighlight">\(-13^\circ\)</span>C.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">T0</span> <span class="o">=</span> <span class="mi">260</span>
<span class="n">A0</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">rate_factor</span><span class="p">(</span><span class="n">T0</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">icepack.constants</span> <span class="k">import</span> <span class="n">glen_flow_law</span> <span class="k">as</span> <span class="n">n</span>
<span class="k">def</span> <span class="nf">viscosity</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">θ</span><span class="p">):</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">A0</span> <span class="o">*</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">θ</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">icepack</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">viscosity</span><span class="o">.</span><span class="n">viscosity_depth_averaged</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>

<span class="n">θ</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>

<span class="n">ice_shelf</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">IceShelf</span><span class="p">(</span><span class="n">viscosity</span><span class="o">=</span><span class="n">viscosity</span><span class="p">)</span>
<span class="n">opts</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;dirichlet_ids&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="s1">&#39;tol&#39;</span><span class="p">:</span> <span class="mf">1e-6</span><span class="p">}</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">ice_shelf</span><span class="o">.</span><span class="n">diagnostic_solve</span><span class="p">(</span><span class="n">u0</span><span class="o">=</span><span class="n">u_obs</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span> <span class="n">θ</span><span class="o">=</span><span class="n">θ</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">contours</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">tricontourf</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">contours</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/icepack.demo.04-ice-shelf-inverse_12_0.png" src="_images/icepack.demo.04-ice-shelf-inverse_12_0.png" />
</div>
<div class="section" id="inferring-the-fluidity">
<h2>Inferring the fluidity<a class="headerlink" href="#inferring-the-fluidity" title="Permalink to this headline">¶</a></h2>
<p>There are four parts that go into an inverse problem:</p>
<ul class="simple">
<li><p>a physics model</p></li>
<li><p>an initial guess for the parameter and state</p></li>
<li><p>an error metric</p></li>
<li><p>a smoothness metric</p></li>
</ul>
<p>We already have the physics model and some initial guesses. The next
step is to write a pair of Python functions that will create the
model-data misfit functional and the regularization functional. We’ll
pass these functions to the inverse problem when we create it.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">firedrake</span> <span class="k">import</span> <span class="n">inner</span><span class="p">,</span> <span class="n">grad</span><span class="p">,</span> <span class="n">dx</span>
<span class="kn">import</span> <span class="nn">icepack.inverse</span>

<span class="k">def</span> <span class="nf">objective</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(((</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_obs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">σx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">((</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_obs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">σy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span>

<span class="n">L</span> <span class="o">=</span> <span class="mf">5e3</span>
<span class="k">def</span> <span class="nf">regularization</span><span class="p">(</span><span class="n">θ</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">L</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">θ</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">θ</span><span class="p">))</span> <span class="o">*</span> <span class="n">dx</span>
</pre></div>
</div>
<p>Now we create the <code class="docutils literal notranslate"><span class="pre">InverseProblem</span></code> object. We’ve already mentioned
several objects that the inverse problem needs – the model, the initial
guess, some functionals, etc. Additionally, it needs to know the name of
the observed field and the parameter (the <code class="docutils literal notranslate"><span class="pre">state_name</span></code> and
<code class="docutils literal notranslate"><span class="pre">parameter_name</span></code>) arguments, since these values are passed to the
forward solver as keyword arguments.</p>
<p>All the additional arguments to the forward model are passed as a
dictionary <code class="docutils literal notranslate"><span class="pre">model_args</span></code>. In our case, these consist of the thickness
field, the initial guess for the velocity, and the forward solver
tolerance. Finally, to specify the inverse problem, we need to know
where Dirichlet boundary conditions are to be applied, as this affects
how one solves for the Lagrange multiplier field <span class="math notranslate nohighlight">\(\lambda\)</span>.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">problem</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">inverse</span><span class="o">.</span><span class="n">InverseProblem</span><span class="p">(</span>
    <span class="n">model</span><span class="o">=</span><span class="n">ice_shelf</span><span class="p">,</span>
    <span class="n">method</span><span class="o">=</span><span class="n">icepack</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">IceShelf</span><span class="o">.</span><span class="n">diagnostic_solve</span><span class="p">,</span>
    <span class="n">objective</span><span class="o">=</span><span class="n">objective</span><span class="p">,</span>
    <span class="n">regularization</span><span class="o">=</span><span class="n">regularization</span><span class="p">,</span>
    <span class="n">state_name</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">,</span>
    <span class="n">state</span><span class="o">=</span><span class="n">u</span><span class="p">,</span>
    <span class="n">parameter_name</span><span class="o">=</span><span class="s1">&#39;θ&#39;</span><span class="p">,</span>
    <span class="n">parameter</span><span class="o">=</span><span class="n">θ</span><span class="p">,</span>
    <span class="n">model_args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="n">h</span><span class="p">,</span> <span class="s1">&#39;u0&#39;</span><span class="p">:</span> <span class="n">u</span><span class="p">,</span> <span class="s1">&#39;tol&#39;</span><span class="p">:</span> <span class="mf">1e-6</span><span class="p">},</span>
    <span class="n">dirichlet_ids</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Once we’ve created the problem, we then create a solver object that will
iteratively search for a good value of the parameters. The inverse
solver has lots of moving parts, all of which are wrapped in a class
that inherits from <code class="docutils literal notranslate"><span class="pre">icepack.inverse.InverseSolver</span></code>. In our case, we’ll
be using the Gauss-Newton method, which is implemented in
<code class="docutils literal notranslate"><span class="pre">GaussNewtonSolver</span></code>. Using this class should save you from worrying
about too many low-level details, but still provide a good amount of
flexibility and transparency.</p>
<p>As a convenience, the inverse solver can take in a function that it will
call at the end of every iteration. For this demonstration, we’ll have
it print out the values of the misfit and regularization functionals.
You could also, say, make a plot of the state and parameter guess at
every iteration to make a movie of how the algorithm progresses.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">area</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">assemble</span><span class="p">(</span><span class="n">firedrake</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span><span class="p">(</span><span class="n">mesh</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">print_error_and_regularization</span><span class="p">(</span><span class="n">solver</span><span class="p">):</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">assemble</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">objective</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">assemble</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">regularization</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:g}</span><span class="s1">, </span><span class="si">{:g}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">E</span><span class="o">/</span><span class="n">area</span><span class="p">,</span> <span class="n">R</span><span class="o">/</span><span class="n">area</span><span class="p">))</span>
</pre></div>
</div>
<p>To create the solver object, we only need to give it a problem and
optionally the function it will call on each iteration. (In programming
parlance this is called a <em>callback function</em>.)</p>
<p>As a general principle, it’s a good idea to separate out the
<em>specification</em> of a problem, in this case represented by the
<code class="docutils literal notranslate"><span class="pre">InverseProblem</span></code> class, from the method used to solve the problem,
represented by the <code class="docutils literal notranslate"><span class="pre">GaussNewtonSolver</span></code> class.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">inverse</span><span class="o">.</span><span class="n">GaussNewtonSolver</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">print_error_and_regularization</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">12.0533</span><span class="p">,</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Before setting the solver loose, let’s look at the initial search
direction.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">contours</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">tricontourf</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">search_direction</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">contours</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/icepack.demo.04-ice-shelf-inverse_22_0.png" src="_images/icepack.demo.04-ice-shelf-inverse_22_0.png" />
<p>The search direction is obtained by multiplying the inverse of the
Gauss-Newton matrix <span class="math notranslate nohighlight">\(H\)</span> by the gradient <span class="math notranslate nohighlight">\(dJ\)</span> of the
objective function. The Gauss-Newton matrix is dense, so we don’t
actually build the matrix directly. Instead, the solver contains a
procedure to multiply a vector by <span class="math notranslate nohighlight">\(H\)</span>, which is all that’s
necessary for using iterative methods to solve linear systems. Computing
the search direction like this is time-consuming, but results in far
fewer iterations, so it’s a net win.</p>
<p>The solve method takes in a relative convergence tolerance, an absolute
tolerance, and a maximum number of iterations, and it returns the total
number of iterations necessary to achieve the given tolerances. In our
case, we’ll stop once the relative decrease in the objective function
from one iteration to the next is less than 1/200.</p>
<p>The algorithm takes a while to run. Now would be the time to put on a
fresh pot of coffee.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">iterations</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span>
    <span class="n">rtol</span><span class="o">=</span><span class="mf">5e-3</span><span class="p">,</span>
    <span class="n">atol</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
    <span class="n">max_iterations</span><span class="o">=</span><span class="mi">30</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">2.08614</span><span class="p">,</span> <span class="mf">0.278768</span>
<span class="mf">1.0019</span><span class="p">,</span> <span class="mf">0.476694</span>
<span class="mf">1.01201</span><span class="p">,</span> <span class="mf">0.434057</span>
<span class="mf">1.00568</span><span class="p">,</span> <span class="mf">0.43692</span>
</pre></div>
</div>
<p>The algorithm converges in just a few iterations because of how good a
search direction we get from using the Gauss-Newton approximation. Other
methods like gradient descent take many more iterations to reach the
same agreement with the data.</p>
</div>
<div class="section" id="analysis">
<h2>Analysis<a class="headerlink" href="#analysis" title="Permalink to this headline">¶</a></h2>
<p>Now that we’re done, we’ll want to do some post-processing and analysis
on the fluidity parameter that we inferred. The inverse problem object
stores the parameter we’re inferring and the observed field as the
properties <code class="docutils literal notranslate"><span class="pre">parameter</span></code> and <code class="docutils literal notranslate"><span class="pre">state</span></code> respectively. The names are
intentionally not specific to just ice shelves. For other problems, we
might instead be inferring a friction coefficient rather than a
fluidity, or we might be observing the thickness instead of the
velocity. You can see all the publicly visible properties by typing
<code class="docutils literal notranslate"><span class="pre">help(inverse_problem)</span></code>.</p>
<p>First, let’s plot the parameter value and the fluidity.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ctr</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">tricontourf</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">parameter</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">41</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;RdBu&#39;</span><span class="p">,</span> <span class="n">extend</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">ctr</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/icepack.demo.04-ice-shelf-inverse_27_0.png" src="_images/icepack.demo.04-ice-shelf-inverse_27_0.png" />
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">A0</span> <span class="o">*</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">solver</span><span class="o">.</span><span class="n">parameter</span> <span class="o">/</span> <span class="n">n</span><span class="p">),</span> <span class="n">Q</span><span class="p">)</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ctr</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">tricontourf</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">51</span><span class="p">),</span> <span class="n">extend</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">ctr</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/icepack.demo.04-ice-shelf-inverse_28_0.png" src="_images/icepack.demo.04-ice-shelf-inverse_28_0.png" />
<p>The fluidity is much higher around areas of heavy crevassing, such as
the rift opening from the Gipps Ice Rise and the area flowing into it.
Additionally, several areas downstream of the inlets have much higher
fluidity, and these might indicate the formation of marine ice.</p>
<p>The fluidity is substantially lower around the upper left edge of the
ice shelf. Some of the ice might actually be grounded here, in which
case the resulting basal drag would tend to reduce the extensional
strain of the glacier. However, since the only tunable variable for
explaining the observed velocities is the fluidity, the algorithm will
erroneously converge on whatever value of the fluidity can reproduce the
observed values. In this case, the result is a very low value of
<span class="math notranslate nohighlight">\(A\)</span>, but for other problems the bias can go in the other
direction.</p>
<p>To see how well the parameters fit the data, let’s look at the weighted
difference between the computed and observed velocities.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">δu</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">interpolate</span><span class="p">((</span><span class="n">solver</span><span class="o">.</span><span class="n">state</span> <span class="o">-</span> <span class="n">u_obs</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">σ</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">Q</span><span class="p">)</span>
<span class="n">ctr</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">tricontourf</span><span class="p">(</span><span class="n">δu</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">51</span><span class="p">),</span> <span class="n">extend</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">ctr</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/icepack.demo.04-ice-shelf-inverse_31_0.png" src="_images/icepack.demo.04-ice-shelf-inverse_31_0.png" />
<p>The computed ice velocity is mostly similar to observations aside from a
few blips. The most widespread departures from observations occur around
the rifts that flow into the Gipps Ice Rise. We regularized the problem
by looking only for smooth values of the fluidity parameter. As a
consequence, we won’t be able to see sharp changes that might result
from features like crevasses or rifts. We might instead try to use the
total variation functional</p>
<div class="math notranslate nohighlight">
\[R(\theta) = L\int_\Omega|\nabla\theta|dx\]</div>
<p>if we were interested in features like this.</p>
<p>Finally, let’s try and see how much the inferred parameter departed from
our naive initial guess.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">icepack</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">parameter</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">area</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">firedrake</span><span class="o">.</span><span class="n">assemble</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">objective</span><span class="p">)</span> <span class="o">/</span> <span class="n">area</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">2.5145930107256276</span>
<span class="mf">1.0056848931456468</span>
</pre></div>
</div>
<p>The objective function has been reduced by a factor of 10 through the
optimization procedure, and our final approximation departs quite
substantially from the initial guess. This suggests that data
assimilation does give a substantial benefit over an ad-hoc approach
like picking a sensible constant value.</p>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h2>
<p>In this demo, we’ve shown how to back out the fluidity of an ice shelf
from remote sensing observations. We could then use this value, together
with a description of how the fluidity evolves, to initialize a
prognostic model of the ice shelf. For example, we might assume that the
fluidity is a function of ice temperature and damage. The evolution
equations for these fields are fairly simple hyperbolic PDE for which we
can write solvers using firedrake.</p>
<p>The value of the fluidity that we obtained is not at all spatially
homogeneous. Unless we were very clever, we probably couldn’t have come
up with some way to parameterize it to get a reasonable guess.</p>
<p>We would expect from statistical estimation theory that the value of the
misfit functional divided by the shelf area will be around 1. (A sum of
squares of normal random variables has a <span class="math notranslate nohighlight">\(\chi^2\)</span> distribution,
which has mean 1, there are two components of the velocity vector, and
we divide by 2 at the end.) The misfit we obtained once the algorithm
has converged is very close to 1, which is a sign that the
regularization parameter has been dialed in just right. However, we
don’t always get so lucky. Sometimes you can’t fit the data as well as
you expect from statistics, and there are a number of possible “failure
modes”:</p>
<ol class="arabic simple">
<li><p>The error estimates <span class="math notranslate nohighlight">\(\sigma\)</span> could be wrong.</p></li>
<li><p>We don’t have a good way to also account for thickness errors, which
are substantial.</p></li>
<li><p>We regularized the problem too much.</p></li>
<li><p>The ice shelf becomes grounded on some pinning point and we didn’t
add basal drag.</p></li>
<li><p>I implemented the numerical optimization algorithm incorrectly.</p></li>
</ol>
<p>Failure modes 1 and 2 happen because we don’t have the right statistical
distribution for the errors, while failure mode 3 happens because we
don’t have the right prior distribution. Mode 4 is a more insidious type
of failure. In this case, the physics model doesn’t actually describe
the true behavior of the system, and as a consequence is unable to
reproduce the observations with any value of the inputs. Some wrong
physics models may nonetheless be able to reproduce the observations,
provided that they are
<a class="reference external" href="https://en.wikipedia.org/wiki/Controllability">controllable</a> as a
function of the input parameters. Diagnosing this type of failure is
arguably the most difficult. Last but not least is human error in
implementing the optimization algorithms. These kinds of failures should
be caught through testing on synthetic problems.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="icepack.demo.05-hybrid-ice-stream.html" class="btn btn-neutral float-right" title="Ice streams, once more" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="icepack.demo.03-synthetic-ice-stream.html" class="btn btn-neutral float-left" title="Synthetic ice stream" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Daniel Shapero

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>