

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Synthetic ice shelf &mdash; icepack 0.0.3 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Larsen Ice Shelf" href="icepack.demo.02-larsen-ice-shelf.html" />
    <link rel="prev" title="Meshes, functions" href="icepack.demo.00-meshes-functions.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> icepack
          

          
          </a>

          
            
            
              <div class="version">
                0.0.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="background.html">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="contact.html">Contact</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="icepack.demo.00-meshes-functions.html">Meshes, functions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Synthetic ice shelf</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#geometry">Geometry</a></li>
<li class="toctree-l2"><a class="reference internal" href="#input-data">Input data</a></li>
<li class="toctree-l2"><a class="reference internal" href="#modeling">Modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#conclusion">Conclusion</a></li>
<li class="toctree-l2"><a class="reference internal" href="#epilogue-damage">Epilogue: Damage</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="icepack.demo.02-larsen-ice-shelf.html">Larsen Ice Shelf</a></li>
<li class="toctree-l1"><a class="reference internal" href="icepack.demo.03-synthetic-ice-stream.html">Synthetic ice stream</a></li>
<li class="toctree-l1"><a class="reference internal" href="icepack.demo.04-ice-shelf-inverse.html">Inverse problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="icepack.demo.05-hybrid-ice-stream.html">Ice streams, once more</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="design.html">Design</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="modules.html">icepack</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">icepack</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Synthetic ice shelf</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/icepack.demo.01-synthetic-ice-shelf.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tqdm</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">pi</span> <span class="k">as</span> <span class="n">π</span>
<span class="kn">import</span> <span class="nn">firedrake</span>
<span class="kn">from</span> <span class="nn">firedrake</span> <span class="kn">import</span> <span class="n">as_vector</span><span class="p">,</span> <span class="n">inner</span><span class="p">,</span> <span class="n">ds</span>
<span class="kn">import</span> <span class="nn">icepack</span><span class="o">,</span> <span class="nn">icepack.plot</span>
</pre></div>
</div>
<div class="section" id="synthetic-ice-shelf">
<h1>Synthetic ice shelf<a class="headerlink" href="#synthetic-ice-shelf" title="Permalink to this headline">¶</a></h1>
<p>In this demo, we’ll show how to simulate the evolution of a floating ice
shelf. The example that we’ll show is an example of a model <em>spin-up</em>.
In a spin-up experiment, the objective is to obtain a physically
plausible state of some system from an initial guess by simulating its
evolution for a long time. For example, it’s common to spin up climate
models from a very rough initial guess for several thousand years to
obtain a representative state of the atmosphere and oceans for the epoch
you’re interested in.</p>
<p>In our case, we’ll use an idealized ice shelf geometry and a rough guess
for the initial ice thickness. First we’ll solve the <em>diagnostic
equation</em> for the velocity througout the ice shelf. We’ll then solve the
<em>prognostic equation</em> to obtain the ice thickness at a slightly later
time. By assuming a given rate of ice accumulation and melting, we can
successively solve the prognostic and diagnostic equations until the
system is close to a steady state. In our case, that will take about 250
years of model time and (at least on my laptop) only a few minutes of
computer time.</p>
<p>The whole simulation can be divided into three parts:</p>
<ul class="simple">
<li><p>Define the shape of the ice shelf and get a triangulation of the
interior.</p></li>
<li><p>Define the initial guess for the ice thickness and velocity, and set
a value of the rheology and accumulation rate.</p></li>
<li><p>Set the total simulation time and the number of time steps, and then
iteratively update the ice thickness and velocity at each time step.</p></li>
</ul>
<p>This is a pretty common workflow for a predictive model. In later demos
we’ll see some variations on this procedure – incorporating real data,
comparing different physics, and so forth – but the essential idea is
the same throughout.</p>
<div class="section" id="geometry">
<h2>Geometry<a class="headerlink" href="#geometry" title="Permalink to this headline">¶</a></h2>
<p>First we need to define the geometry of the ice shelf. Although we’ll be
solving a synthetic problem, we’ll try to use a more-or-less realistic
shape. The inflow boundary will be a circular arc centered at the origin
with a radius of 200 km. The outflow boundary will be another circular
arc with a much higher radius.</p>
<p>In the first demo, we used one of firedrake’s built-in functions to
create the geometry. For more complicated shapes you’ll need to use a
mesh generator, a program that turns a description of the boundary of a
spatial domain into a triangulation of the interior. Two of the more
popular 2D mesh generators are <a class="reference external" href="http://gmsh.info/">gmsh</a> and
<a class="reference external" href="https://www.cs.cmu.edu/~quake/triangle.html">Triangle</a>. In this case
we’ll use gmsh because we can create the input file entirely in Python
through the package <a class="reference external" href="https://github.com/nschloe/pygmsh">pygmsh</a>.</p>
<p>We’ll first define the mesh radius and the spacing for the mesh cells.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pygmsh</span>

<span class="n">R</span> <span class="o">=</span> <span class="mf">200e3</span>
<span class="n">δx</span> <span class="o">=</span> <span class="mf">5e3</span>
</pre></div>
</div>
<p>Next, we’ll create an empty geometry and add some points to it. The
points <code class="docutils literal notranslate"><span class="pre">x1</span></code>, <code class="docutils literal notranslate"><span class="pre">x2</span></code> will represent the left and right endpoints of the
mesh. The points <code class="docutils literal notranslate"><span class="pre">center1</span></code>, <code class="docutils literal notranslate"><span class="pre">center2</span></code> will not actually be contained
in the mesh, but rather define the centers of the two circular arcs.
Finally, we’ll add the circular arcs.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">geometry</span> <span class="o">=</span> <span class="n">pygmsh</span><span class="o">.</span><span class="n">built_in</span><span class="o">.</span><span class="n">Geometry</span><span class="p">()</span>

<span class="n">x1</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">add_point</span><span class="p">([</span><span class="o">-</span><span class="n">R</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">lcar</span><span class="o">=</span><span class="n">δx</span><span class="p">)</span>
<span class="n">x2</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">add_point</span><span class="p">([</span><span class="o">+</span><span class="n">R</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">lcar</span><span class="o">=</span><span class="n">δx</span><span class="p">)</span>

<span class="n">center1</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">add_point</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,],</span> <span class="n">lcar</span><span class="o">=</span><span class="n">δx</span><span class="p">)</span>
<span class="n">center2</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">add_point</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span> <span class="o">*</span> <span class="n">R</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">lcar</span><span class="o">=</span><span class="n">δx</span><span class="p">)</span>

<span class="n">arcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">geometry</span><span class="o">.</span><span class="n">add_circle_arc</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">center1</span><span class="p">,</span> <span class="n">x2</span><span class="p">),</span>
        <span class="n">geometry</span><span class="o">.</span><span class="n">add_circle_arc</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">center2</span><span class="p">,</span> <span class="n">x1</span><span class="p">)]</span>
</pre></div>
</div>
<p>Now that we’ve added the geometric elements of our domain, we also need
to tell gmsh about the topology, i.e. how all the arcs are connected to
each other and how they’re oriented. The physical lines and surfaces are
added so that gmsh will tag each geometric entity with a number that we
can use to set different boundary conditions.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">line_loop</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">add_line_loop</span><span class="p">(</span><span class="n">arcs</span><span class="p">)</span>
<span class="n">plane_surface</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">add_plane_surface</span><span class="p">(</span><span class="n">line_loop</span><span class="p">)</span>

<span class="n">physical_lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">geometry</span><span class="o">.</span><span class="n">add_physical</span><span class="p">(</span><span class="n">arc</span><span class="p">)</span> <span class="k">for</span> <span class="n">arc</span> <span class="ow">in</span> <span class="n">arcs</span><span class="p">]</span>
<span class="n">physical_surface</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">add_physical</span><span class="p">(</span><span class="n">plane_surface</span><span class="p">)</span>
</pre></div>
</div>
<p>This completes the definition of the input geometry. The method
<code class="docutils literal notranslate"><span class="pre">get_code</span></code> of the geometry object returns the string describing it in
the syntax that gmsh expects. We’ll write this string out to a file with
the extension <code class="docutils literal notranslate"><span class="pre">.geo</span></code>.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;ice-shelf.geo&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">geo_file</span><span class="p">:</span>
    <span class="n">geo_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">get_code</span><span class="p">())</span>
</pre></div>
</div>
<p>Next, we’ll call gmsh from the command line on the input file we just
created. The mesh generator will read the description of the domain
boundary, triangulate the interior of the domain, and output a file with
the extension <code class="docutils literal notranslate"><span class="pre">.msh</span></code>. Other mesh generators have different input and
output formats, but the procedure is roughly the same.</p>
<p>In a jupyter notebook, you can use an exclamation mark followed by a
command to execute this command at the shell rather than in Python.
We’ll call <code class="docutils literal notranslate"><span class="pre">gmsh</span></code> from the command line with the following arguments:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-2</span></code>: generate a 2D mesh as opposed to 3D</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-format</span> <span class="pre">msh2</span></code>: specify the storage format of the output file</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-o</span> <span class="pre">ice-shelf.msh</span></code>: name of the output file</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ice-shelf.geo</span></code>: the input data</p></li>
</ul>
<p>The shell command (without the exclamation mark) is what you would use
if you were working directly from the command line rather than in a
notebook.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">!</span>gmsh -2 -format msh2 -o ice-shelf.msh ice-shelf.geo
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Info</span>    <span class="p">:</span> <span class="n">Running</span> <span class="s1">&#39;gmsh -2 -format msh2 -o ice-shelf.msh ice-shelf.geo&#39;</span> <span class="p">[</span><span class="n">Gmsh</span> <span class="mf">4.5</span><span class="o">.</span><span class="mi">6</span><span class="p">,</span> <span class="mi">1</span> <span class="n">node</span><span class="p">,</span> <span class="nb">max</span><span class="o">.</span> <span class="mi">1</span> <span class="n">thread</span><span class="p">]</span>
<span class="n">Info</span>    <span class="p">:</span> <span class="n">Started</span> <span class="n">on</span> <span class="n">Mon</span> <span class="n">Sep</span>  <span class="mi">7</span> <span class="mi">10</span><span class="p">:</span><span class="mi">05</span><span class="p">:</span><span class="mi">28</span> <span class="mi">2020</span>
<span class="n">Info</span>    <span class="p">:</span> <span class="n">Reading</span> <span class="s1">&#39;ice-shelf.geo&#39;</span><span class="o">...</span>
<span class="n">Info</span>    <span class="p">:</span> <span class="n">Done</span> <span class="n">reading</span> <span class="s1">&#39;ice-shelf.geo&#39;</span>
<span class="n">Info</span>    <span class="p">:</span> <span class="n">Meshing</span> <span class="mi">1</span><span class="n">D</span><span class="o">...</span>
<span class="n">Info</span>    <span class="p">:</span> <span class="p">[</span>  <span class="mi">0</span> <span class="o">%</span><span class="p">]</span> <span class="n">Meshing</span> <span class="n">curve</span> <span class="mi">1</span> <span class="p">(</span><span class="n">Circle</span><span class="p">)</span>
<span class="n">Info</span>    <span class="p">:</span> <span class="p">[</span> <span class="mi">50</span> <span class="o">%</span><span class="p">]</span> <span class="n">Meshing</span> <span class="n">curve</span> <span class="mi">2</span> <span class="p">(</span><span class="n">Circle</span><span class="p">)</span>
<span class="n">Info</span>    <span class="p">:</span> <span class="n">Done</span> <span class="n">meshing</span> <span class="mi">1</span><span class="n">D</span> <span class="p">(</span><span class="mf">0.000671</span> <span class="n">s</span><span class="p">)</span>
<span class="n">Info</span>    <span class="p">:</span> <span class="n">Meshing</span> <span class="mi">2</span><span class="n">D</span><span class="o">...</span>
<span class="n">Info</span>    <span class="p">:</span> <span class="n">Meshing</span> <span class="n">surface</span> <span class="mi">4</span> <span class="p">(</span><span class="n">Plane</span><span class="p">,</span> <span class="n">Frontal</span><span class="o">-</span><span class="n">Delaunay</span><span class="p">)</span>
<span class="n">Info</span>    <span class="p">:</span> <span class="n">Done</span> <span class="n">meshing</span> <span class="mi">2</span><span class="n">D</span> <span class="p">(</span><span class="mf">0.10108</span> <span class="n">s</span><span class="p">)</span>
<span class="n">Info</span>    <span class="p">:</span> <span class="mi">3373</span> <span class="n">nodes</span> <span class="mi">6744</span> <span class="n">elements</span>
<span class="n">Info</span>    <span class="p">:</span> <span class="n">Writing</span> <span class="s1">&#39;ice-shelf.msh&#39;</span><span class="o">...</span>
<span class="n">Info</span>    <span class="p">:</span> <span class="n">Done</span> <span class="n">writing</span> <span class="s1">&#39;ice-shelf.msh&#39;</span>
<span class="n">Info</span>    <span class="p">:</span> <span class="n">Stopped</span> <span class="n">on</span> <span class="n">Mon</span> <span class="n">Sep</span>  <span class="mi">7</span> <span class="mi">10</span><span class="p">:</span><span class="mi">05</span><span class="p">:</span><span class="mi">28</span> <span class="mi">2020</span>
</pre></div>
</div>
<p>The terminal output from gmsh gives us some diagnostics like how many
vertices and triangles it contains. This is also where gmsh will report
if something went wrong – a syntax error in the .geo file, a degenerate
input geometry, and so forth.</p>
<p>To load the mesh we pass the filename to the function
<code class="docutils literal notranslate"><span class="pre">firedrake.Mesh</span></code>. This function will determine the mesh format based
on the file extension; it works for meshes that were generated by
Triangle or other programs as well.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mesh</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">Mesh</span><span class="p">(</span><span class="s1">&#39;ice-shelf.msh&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The colors in the figure below show how gmsh tagged the calving terminus
with ID 2 and the inflow boundary as 1. This is exactly analogous to how
firedrake adds tags for each side of the square geometry that we used in
the previous demo. These numeric tags help us define Dirichlet (inflow)
and Neumann (terminus) boundary conditions where they apply.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">triplot</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/icepack.demo.01-synthetic-ice-shelf_16_0.png" src="_images/icepack.demo.01-synthetic-ice-shelf_16_0.png" />
<p>In the demos for real glaciers that follow, we use all of the same
tools. The main difference is that the boundary arcs are drawn by hand
in a geographic information system, rather than defined programatically
in Python. In the repository
<a class="reference external" href="https://github.com/icepack/glacier-meshes">glacier-meshes</a> I’ve
included shapefiles of the outlines of several glaciers and a program to
automate the translation of a shapefile into a .geo file using pygmsh.
This will be used in the demo for the Larsen Ice Shelf.</p>
</div>
<div class="section" id="input-data">
<h2>Input data<a class="headerlink" href="#input-data" title="Permalink to this headline">¶</a></h2>
<p>To mimic the state of a real ice shelf, we’ll pick a few angles along
the inflow boundary that represent the centerlines of the ice streams
that feed the shelf. We’ll then define velocity and thickness profiles
along this inflow boundary. We don’t have a great idea from the outset
of what the steady state of the ice shelf is; it doesn’t have a simple
analytical expression in terms of the coordinates. Instead, we’ll pick a
somewhat arbitrary initial profile and evolve it towards steady state.</p>
<p>Many ice shelves (Larsen, Ross, etc.) have several streams feeding them.
Our synthetic glacier will be fed by four streams. We’ll define the
inlets by picking the angles around the inflow boundary where each inlet
comes in from and the width in radians. You can re-run this notebook and
change the values or the number of streams to whatever you like.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">inlet_angles</span> <span class="o">=</span> <span class="n">π</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">6</span><span class="p">])</span>
<span class="n">inlet_widths</span> <span class="o">=</span> <span class="n">π</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">12</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">24</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">12</span><span class="p">])</span>
</pre></div>
</div>
<p>Next, we’ll come up with some rather arbitrary and un-physical input
data. The basic idea is to make the thickness slope down as you go
towards the calving terminus and away from the centerline of an inlet.
Likewise the ice speed goes up as you go towards the calving terminus.
In order to make this big nasty algebraic expression, we’ll create a
list of the perturbation thickness and velocity for each inlet, and
combine them all together at the end.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">SpatialCoordinate</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

<span class="n">u_in</span> <span class="o">=</span> <span class="mi">300</span>
<span class="n">h_in</span> <span class="o">=</span> <span class="mi">350</span>
<span class="n">hb</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">dh</span><span class="p">,</span> <span class="n">du</span> <span class="o">=</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">250</span>

<span class="n">hs</span><span class="p">,</span> <span class="n">us</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">θ</span><span class="p">,</span> <span class="n">ϕ</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inlet_angles</span><span class="p">,</span> <span class="n">inlet_widths</span><span class="p">):</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">R</span> <span class="o">*</span> <span class="n">as_vector</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">θ</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">θ</span><span class="p">)))</span>
    <span class="n">v</span> <span class="o">=</span> <span class="o">-</span><span class="n">as_vector</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">θ</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">θ</span><span class="p">)))</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x0</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x0</span> <span class="o">-</span> <span class="n">L</span> <span class="o">*</span> <span class="n">v</span>
    <span class="n">Rn</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ϕ</span> <span class="o">/</span> <span class="n">π</span> <span class="o">*</span> <span class="n">R</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">max_value</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">W</span> <span class="o">/</span> <span class="n">Rn</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">hs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hb</span> <span class="o">+</span> <span class="n">q</span> <span class="o">*</span> <span class="p">((</span><span class="n">h_in</span> <span class="o">-</span> <span class="n">hb</span><span class="p">)</span> <span class="o">-</span> <span class="n">dh</span> <span class="o">*</span> <span class="n">L</span> <span class="o">/</span><span class="n">R</span><span class="p">))</span>
    <span class="n">us</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">firedrake</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">W</span><span class="o">/</span><span class="n">R</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">u_in</span> <span class="o">+</span> <span class="n">du</span> <span class="o">*</span> <span class="n">L</span> <span class="o">/</span> <span class="n">R</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p>To combine the expressions for the thickness and velocity of each inlet
into expressions for the whole ice shelf, we’ll take the maximum
thickness at any point, and the sum of the velocities.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">h_expr</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">hb</span><span class="p">)</span>
<span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hs</span><span class="p">:</span>
    <span class="n">h_expr</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">max_value</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">h_expr</span><span class="p">)</span>

<span class="n">u_expr</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">us</span><span class="p">)</span>
</pre></div>
</div>
<p>These are merely algebraic expressions. To start modeling we need to
interpolate these expressions to some function spaces defined over the
mesh.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Q</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="s1">&#39;CG&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="s1">&#39;CG&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">h0</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">h_expr</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
<span class="n">u0</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">u_expr</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<p>The algebra might be a little opaque, but the plots of the initial data
should be more illuminating.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">axes</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Thickness&#39;</span><span class="p">)</span>
<span class="n">contours</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">tricontourf</span><span class="p">(</span><span class="n">h0</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">contours</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/icepack.demo.01-synthetic-ice-shelf_27_0.png" src="_images/icepack.demo.01-synthetic-ice-shelf_27_0.png" />
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">axes</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Velocity&#39;</span><span class="p">)</span>
<span class="n">streamlines</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">streamplot</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="mf">2e3</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">streamlines</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/icepack.demo.01-synthetic-ice-shelf_28_0.png" src="_images/icepack.demo.01-synthetic-ice-shelf_28_0.png" />
<p>As the simulation progresses, the ice streams, as represented by areas
with higher thickness, will spread and grow.</p>
</div>
<div class="section" id="modeling">
<h2>Modeling<a class="headerlink" href="#modeling" title="Permalink to this headline">¶</a></h2>
<p>To actually start solving things, we need to make two objects. First,
the class <code class="docutils literal notranslate"><span class="pre">IceShelf</span></code> represents what physics problem we’re interested
in. In later tutorials we’ll show how to alter the components of a
particular physics model and how to use other models entirely.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">IceShelf</span><span class="p">()</span>
</pre></div>
</div>
<p>Second, the class <code class="docutils literal notranslate"><span class="pre">FlowSolver</span></code> decides how we’re going to solve that
problem. When we initialize the flow solver we pass it any arguments
that never change throughout a simulation. For example, the parts of the
domain boundary where we apply Dirichlet boundary conditions have to
stay the same throughout the whole simulation, and the list of those
boundary IDs is passed in the keyword argument <code class="docutils literal notranslate"><span class="pre">dirichlet_ids</span></code>.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">solvers</span><span class="o">.</span><span class="n">FlowSolver</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">dirichlet_ids</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>The main job of the flow solver object is to solve the PDEs for ice
velocity and thickness, for which it has two methods,
<code class="docutils literal notranslate"><span class="pre">diagnostic_solve</span></code> and <code class="docutils literal notranslate"><span class="pre">prognostic_solve</span></code>. These two methods are all
that you need to describe the evolution of an ice shelf.</p>
<p>We need one more input variable, the fluidity factor <span class="math notranslate nohighlight">\(A\)</span> in Glen’s
flow law <span class="math notranslate nohighlight">\(\dot\varepsilon = A\tau^3\)</span>. The fluidity depends on
several variables, especially the temperature of the ice; warmer ice is
easier to deform. For now we’ll use a fluidity that comes from a
spatially constant temperature of -18C. The code itself assumes that all
temperatures are in Kelvin. At the end of this demo, we’ll show how to
incorporate the effect of ice damage on the fluidity.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mf">255.15</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">rate_factor</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
</pre></div>
</div>
<p>To compute the velocity field, we’ll call the diagnostic solve method of
the ice shelf object. This method takes in the thickness, the fluidity
factor <span class="math notranslate nohighlight">\(A\)</span>, and the initial guess for the ice velocity. The
keywords we use for these fields are exactly the same as their names.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">h</span> <span class="o">=</span> <span class="n">h0</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deepcopy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">diagnostic_solve</span><span class="p">(</span>
    <span class="n">velocity</span><span class="o">=</span><span class="n">u0</span><span class="p">,</span>
    <span class="n">thickness</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
    <span class="n">fluidity</span><span class="o">=</span><span class="n">A</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The following plot shows streamlines of the velocity field. These kind
of plots are useful for showing areas of convergence and divergence of
the flow field.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">streamlines</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">streamplot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="mf">2e3</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">streamlines</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;meters/year&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/icepack.demo.01-synthetic-ice-shelf_40_0.png" src="_images/icepack.demo.01-synthetic-ice-shelf_40_0.png" />
<p>To project the state of the ice shelf forward in time, we’ll use the
prognostic solve method. The prognostic solver updates the ice thickness
forward by a given timestep given the accumulation rate and velocity. We
then update the velocity using the diagnostic solver at each timestep.
The following code runs the model forward for several years until the
ice shelf is roughly in steady state.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">final_time</span> <span class="o">=</span> <span class="mf">400.</span>
<span class="n">num_timesteps</span> <span class="o">=</span> <span class="mi">200</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">final_time</span> <span class="o">/</span> <span class="n">num_timesteps</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>

<span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">trange</span><span class="p">(</span><span class="n">num_timesteps</span><span class="p">):</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">prognostic_solve</span><span class="p">(</span>
        <span class="n">dt</span><span class="p">,</span>
        <span class="n">thickness</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
        <span class="n">velocity</span><span class="o">=</span><span class="n">u</span><span class="p">,</span>
        <span class="n">accumulation</span><span class="o">=</span><span class="n">a</span><span class="p">,</span>
        <span class="n">thickness_inflow</span><span class="o">=</span><span class="n">h0</span>
    <span class="p">)</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">diagnostic_solve</span><span class="p">(</span>
        <span class="n">velocity</span><span class="o">=</span><span class="n">u</span><span class="p">,</span>
        <span class="n">thickness</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
        <span class="n">fluidity</span><span class="o">=</span><span class="n">A</span>
    <span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>100%|██████████| 200/200 [04:23&lt;00:00,  1.32s/it]
</pre></div>
</div>
<p>The main loop to run the simulation consists of alternating calls to the
prognostic and diagnostic solve methods of the model object. We’ll see
this pattern repeated in all of the demos that follow. In some cases
we’ll add in extra physics, like updating the temperature or damage
field, but the core idea is the same.</p>
<p><strong>All of the fields involved in this simulation – the ice thickness,
velocity, and so forth – were passed by keyword.</strong> Only the timestep
<code class="docutils literal notranslate"><span class="pre">dt</span></code> was passed by position. This is true more broadly of every
solving routine in icepack. Passing arguments by keyword is admittedly
more verbose than passing them by position, but we’ve made this choice
for an important reason. As we’ll show later on in this demo, passing
arguments by keyword makes it possible to swap out components of the
model physics for your own customized versions. This flexibility would
be impossible if we passed these fields by position. Finally, keyword
arguments save you the trouble of remembering what order everything goes
in; you only have to remember their names.</p>
<p>As a typographical convenience, we’ve put every argument on its own
line. This isn’t strictly necessary and you can adopt whatever
convention you like for indenting your own code. We’ve found that using
a separate line for each argument when calling really important
functions makes them stand out visually, and makes it easiest to quickly
scan over the argument list.</p>
<p>We’ve added a progress bar using the package
<a class="reference external" href="https://tqdm.github.io/">tqdm</a> to give a bit of feedback about how
long the simulation will take. These kinds of diagnostics are helpful to
know that the simulation is actually running and that it hasn’t frozen.
But you can also put in whatever extra code you want here. For example,
you might want to make plots of the thickness and velocity, print out
some physical quantity like the total flux of ice out of the calving
front, or accumulate the fields into a list so that you can analyze the
entire time series later.</p>
<p>To wrap things up, we’ll make a plot of the final ice thickness and
velocity. The initial thickness profile of each ice stream, which
flattened out in the middle of the shelf, has extended all the way to
the terminus.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">contours</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">tricontourf</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">contours</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;meters&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/icepack.demo.01-synthetic-ice-shelf_44_0.png" src="_images/icepack.demo.01-synthetic-ice-shelf_44_0.png" />
<p>A stream plot of the ice velocity shows that the areas of greatest flow
divergence have moved around relative to the initial velocity.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">streamlines</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">streamplot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="mf">2e3</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">streamlines</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;meters/year&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/icepack.demo.01-synthetic-ice-shelf_46_0.png" src="_images/icepack.demo.01-synthetic-ice-shelf_46_0.png" />
<p>A useful quantity to know is how much ice is moving through the system.
In the previous demo, we showed how to symbolically create functionals
of the solution. We can use this to calculate the total ice flux through
the calving terminus.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ν</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">flux</span> <span class="o">=</span> <span class="n">h</span> <span class="o">*</span> <span class="n">inner</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">ν</span><span class="p">)</span> <span class="o">*</span> <span class="n">ds</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>The extra argument to <code class="docutils literal notranslate"><span class="pre">ds</span></code> indicates that we want to integrate over
just the calving terminus rather than over the entire domain boundary.
The variable <code class="docutils literal notranslate"><span class="pre">flux</span></code> is a symbolic representation of this quantity in
terms of the input fields; it isn’t a number but rather a description of
how to compute a number. The function <code class="docutils literal notranslate"><span class="pre">firedrake.assemble</span></code> does the
actual work of evaluating the integral.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Flux: </span><span class="si">{}</span><span class="s1"> km^3 / year&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">firedrake</span><span class="o">.</span><span class="n">assemble</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1e9</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Flux</span><span class="p">:</span> <span class="mf">38.10962034251982</span> <span class="n">km</span><span class="o">^</span><span class="mi">3</span> <span class="o">/</span> <span class="n">year</span>
</pre></div>
</div>
<p>To check the degree to which the system really is in steady state, we
can compute the flux along the inflow boundary rather than along the
terminus. This should be equal to the flux out of the domain since we’ve
set the accumulation rate to be zero.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">influx</span> <span class="o">=</span> <span class="o">-</span><span class="n">h</span> <span class="o">*</span> <span class="n">inner</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">ν</span><span class="p">)</span> <span class="o">*</span> <span class="n">ds</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Influx: </span><span class="si">{}</span><span class="s1"> km^3 / year&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">firedrake</span><span class="o">.</span><span class="n">assemble</span><span class="p">(</span><span class="n">influx</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1e9</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Influx</span><span class="p">:</span> <span class="mf">38.14282879795248</span> <span class="n">km</span><span class="o">^</span><span class="mi">3</span> <span class="o">/</span> <span class="n">year</span>
</pre></div>
</div>
<p>The influx and outflux are reasonably close, with the influx slightly
exceeding the outflux. The ice shelf will thicken, increasing the flux
out of the terminus, until the two values equilibrate.</p>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h2>
<p>In the last demo, we saw how to create a mesh, define a finite element
space, interpolate functions to that finite element space, and analyze
the results. Here we’ve shown how to use these functions as an input to
an ice shelf flow model. If you want to experiment with this example a
bit more, you can run this notebook yourself and:</p>
<ul class="simple">
<li><p>change the curvature of the inflow boundary or the calving terminus</p></li>
<li><p>change the stream widths, thicknesses, or velocities</p></li>
<li><p>add a sinusoidal variation in the accumulation rate to approximate
seasonal cycles</p></li>
</ul>
<p>In the next demo, we’ll show how to use these functions for simulating a
real ice shelf in the Antarctic Peninsula using observational data from
satellites. As a bonus epilogue to this demo, we’ll show how to also
include the physics of damage and crevassing.</p>
</div>
<div class="section" id="epilogue-damage">
<h2>Epilogue: Damage<a class="headerlink" href="#epilogue-damage" title="Permalink to this headline">¶</a></h2>
<p>The simulation we just ran uses the prognostic and diagnostic model
physics of ice shelf flow. These models successively update the ice
thickness and velocity. We assumed that the ice rheology was constant in
space in order to simplify things, but this is never true for real ice
shelves. Here we’ll show how to add a model for how crevasses and rifts
affect glacier flow.</p>
<p>As ice becomes more damaged, the same driving stress must be transferred
through a smaller total cross-sectional area of the ice. We can
incorporate the effect of crevasses and rifts into large-scale models of
glacier velocity by increasing the fluidity of the ice column. The
extent of the damage is quantified in a scalar field <span class="math notranslate nohighlight">\(D\)</span> which
takes values between 0 (undamaged) and 1 (completely damaged). Following
<a class="reference external" href="https://doi.org/10.3189/2012JoG11J191">Albrecht and Levermann</a>, we
define the damaged rate factor <span class="math notranslate nohighlight">\(A_D\)</span> to be</p>
<div class="math notranslate nohighlight">
\[A_D = (1 - D)^{-n}A(T)\]</div>
<p>where <span class="math notranslate nohighlight">\(n = 3\)</span> is the Glen flow law exponent and <span class="math notranslate nohighlight">\(A(T)\)</span> is
the rate factor for undamaged ice at temperature <span class="math notranslate nohighlight">\(T\)</span>. As the
damage field approaches is maximum value of 1, the fluidity goes to
infinity. A large-scale calving event would occur before this limit is
reached for a real glacier, but we won’t include this effect here.</p>
<p>The ice shelf model includes several functions for calculating the net
power dissipation of the ice shelf. The velocity that solves the
diagnostic equations minimizes this power dissipation functional. To
incorporate damage, we need to create our own function that calculates
the viscous power dissipation in the presence of damage. The default
function to calculate the viscous power dissipation lives in the module
<code class="docutils literal notranslate"><span class="pre">icepack.models.viscosity</span></code>, so all we need to do is pass the damaged
fluidity <span class="math notranslate nohighlight">\((1 - D)^{-n}\cdot A\)</span> instead of just <span class="math notranslate nohighlight">\(A\)</span> itself.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">icepack.constants</span> <span class="kn">import</span> <span class="n">glen_flow_law</span> <span class="k">as</span> <span class="n">n</span>
<span class="kn">from</span> <span class="nn">icepack.models.viscosity</span> <span class="kn">import</span> <span class="n">viscosity_depth_averaged</span>
<span class="k">def</span> <span class="nf">viscosity_damaged</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;velocity&#39;</span><span class="p">]</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;thickness&#39;</span><span class="p">]</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fluidity&#39;</span><span class="p">]</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;damage&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">viscosity_depth_averaged</span><span class="p">(</span>
        <span class="n">velocity</span><span class="o">=</span><span class="n">u</span><span class="p">,</span>
        <span class="n">thickness</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
        <span class="n">fluidity</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">D</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>We can then create a new ice shelf model object and solver that will use
<code class="docutils literal notranslate"><span class="pre">viscosity_damaged</span></code> to calculate the power dissipation instead of the
default.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">flow_model</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">IceShelf</span><span class="p">(</span><span class="n">viscosity</span><span class="o">=</span><span class="n">viscosity_damaged</span><span class="p">)</span>
<span class="n">flow_solver</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">solvers</span><span class="o">.</span><span class="n">FlowSolver</span><span class="p">(</span><span class="n">flow_model</span><span class="p">,</span> <span class="n">dirichlet_ids</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>The procedure is exactly the same to modify any other part of the
physics of any model. For example, you could also change how the
back-pressure at the calving terminus is computed in order to account
for the presence of ice melange. In later tutorials, we’ll look at
alternative models for basal friction, and we’ll swap out the model
physics in exactly the same way.</p>
<p>So far, we’ve decided how to incorporate damage into the diagnostic
model for the ice velocity. We also need some rule for how damage will
evolve. One approach would be to use fracture mechanics to explicitly
model individual crevasses, but this approach would be very
computationally expensive. Instead, the <em>continuum damage mechanics</em>
approximation posits that there is some bulk transport law for damage
that looks something like this:</p>
<div class="math notranslate nohighlight">
\[\frac{\partial D}{\partial t} + u\cdot\nabla D = f_o - f_c\]</div>
<p>where <span class="math notranslate nohighlight">\(f_o\)</span> is a crevasse opening term and <span class="math notranslate nohighlight">\(f_c\)</span> is a
crevasse closing or healing term. Crevasses open when the stress is
sufficiently high, and crevasses close when the strain rate is low or
compressional. The real physics comes in deciding the exact details of
how these terms depend on the stress, strain rate, and other variables.
In the following, we’ll use the model from <a class="reference external" href="https://doi.org/10.3189/2012JoG11J191">Albrecht and
Levermann</a>, but there are many
others.</p>
<p>The class <code class="docutils literal notranslate"><span class="pre">icepack.models.DamageTransport</span></code> describes the damage
transport law, while <code class="docutils literal notranslate"><span class="pre">icepack.solvers.DamageSolver</span></code> contains routines
for actually solving it. We’ll initialize the damage field to be zero
everywhere and we’ll advect in zero damage from upstream.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">damage_model</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">DamageTransport</span><span class="p">()</span>
<span class="n">damage_solver</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">solvers</span><span class="o">.</span><span class="n">DamageSolver</span><span class="p">(</span><span class="n">damage_model</span><span class="p">)</span>

<span class="n">Δ</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="s1">&#39;DG&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">Δ</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, we’ll run a new simulation that includes interleaved updates for
ice thickness and velocity, just like before, but also an update for the
damage field according to the transport law we wrote down above. The
simulation will go for long enough to propagate the damage field through
an entire residence time of the ice shelf. Note how the diagnostic solve
procedure now takes the damage field as a keyword argument in addition
to the other fields we’ve already seen.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">trange</span><span class="p">(</span><span class="n">num_timesteps</span><span class="p">):</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">flow_solver</span><span class="o">.</span><span class="n">prognostic_solve</span><span class="p">(</span>
        <span class="n">dt</span><span class="p">,</span>
        <span class="n">thickness</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
        <span class="n">velocity</span><span class="o">=</span><span class="n">u</span><span class="p">,</span>
        <span class="n">accumulation</span><span class="o">=</span><span class="n">a</span><span class="p">,</span>
        <span class="n">thickness_inflow</span><span class="o">=</span><span class="n">h0</span>
    <span class="p">)</span>

    <span class="n">D</span> <span class="o">=</span> <span class="n">damage_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span>
        <span class="n">dt</span><span class="p">,</span>
        <span class="n">damage</span><span class="o">=</span><span class="n">D</span><span class="p">,</span>
        <span class="n">velocity</span><span class="o">=</span><span class="n">u</span><span class="p">,</span>
        <span class="n">fluidity</span><span class="o">=</span><span class="n">A</span><span class="p">,</span>
        <span class="n">damage_inflow</span><span class="o">=</span><span class="n">firedrake</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">flow_solver</span><span class="o">.</span><span class="n">diagnostic_solve</span><span class="p">(</span>
        <span class="n">velocity</span><span class="o">=</span><span class="n">u</span><span class="p">,</span>
        <span class="n">thickness</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
        <span class="n">fluidity</span><span class="o">=</span><span class="n">A</span><span class="p">,</span>
        <span class="n">damage</span><span class="o">=</span><span class="n">D</span>
    <span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>100%|██████████| 200/200 [03:58&lt;00:00,  1.19s/it]
</pre></div>
</div>
<p>Finally we’ll plot the result. An interesting feature you can see in the
final result is that the damage field is highest <em>in between</em> the ice
streams. These aren’t the areas where the velocity is highest, but
rather where the shear strain rate is highest.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">colors</span> <span class="o">=</span> <span class="n">icepack</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">tripcolor</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/icepack.demo.01-synthetic-ice-shelf_64_0.png" src="_images/icepack.demo.01-synthetic-ice-shelf_64_0.png" />
<p>If you want to experiment with this problem further, you can try:</p>
<ul class="simple">
<li><p>changing the parameters of the damage model, such as the critical
stress at which damage grows; see <code class="docutils literal notranslate"><span class="pre">DamageTransport.__init__</span></code> for a
full list and the default values</p></li>
<li><p>changing the inflow velocities of each ice stream; the larger the
speed contrasts between neighboring streams, the greater the damage
between them</p></li>
<li><p>adding an ice rise to the domain to see how shear around this
obstacle affects damage.</p></li>
</ul>
<p>Damage mechanics is one of many things you might want to simulate in
order to accurately capture the physics of glacier flow. In later demos,
we’ll show how to incorporate heat transfer. We could also include
models describing things like the buoyant plume of meltwater in the top
layer of ocean underneath the ice shelf, or the densification of firn on
the ice surface. The details are different in each case, but the
essential procedure is the same: first decide how the addition of a new
field will affect the flow, and then decide how this field will evolve
in time. We used the continuum damage formulation of Albrecht and
Levermann, but there are many other models we could have chosen.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="icepack.demo.02-larsen-ice-shelf.html" class="btn btn-neutral float-right" title="Larsen Ice Shelf" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="icepack.demo.00-meshes-functions.html" class="btn btn-neutral float-left" title="Meshes, functions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2017, Daniel Shapero

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>