

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>icepack.inverse module &mdash; icepack 0.0.3 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="icepack.norms module" href="icepack.norms.html" />
    <link rel="prev" title="icepack.interpolate module" href="icepack.interpolate.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> icepack
          

          
          </a>

          
            
            
              <div class="version">
                0.0.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
</ul>
<p class="caption"><span class="caption-text">Demos:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="icepack.demo.00-meshes-functions.html">Meshes, functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="icepack.demo.01-synthetic-ice-shelf.html">Synthetic ice shelf</a></li>
<li class="toctree-l1"><a class="reference internal" href="icepack.demo.02-larsen-ice-shelf.html">Larsen Ice Shelf</a></li>
<li class="toctree-l1"><a class="reference internal" href="icepack.demo.03-synthetic-ice-stream.html">Synthetic ice stream</a></li>
<li class="toctree-l1"><a class="reference internal" href="icepack.demo.04-ice-shelf-inverse.html">Inverse problems</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">icepack</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="icepack.html">icepack package</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="icepack.html#subpackages">Subpackages</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="icepack.html#submodules">Submodules</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="icepack.constants.html">icepack.constants module</a></li>
<li class="toctree-l4"><a class="reference internal" href="icepack.interpolate.html">icepack.interpolate module</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">icepack.inverse module</a></li>
<li class="toctree-l4"><a class="reference internal" href="icepack.norms.html">icepack.norms module</a></li>
<li class="toctree-l4"><a class="reference internal" href="icepack.optimization.html">icepack.optimization module</a></li>
<li class="toctree-l4"><a class="reference internal" href="icepack.plot.html">icepack.plot module</a></li>
<li class="toctree-l4"><a class="reference internal" href="icepack.utilities.html">icepack.utilities module</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">icepack</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="modules.html">icepack</a> &raquo;</li>
        
          <li><a href="icepack.html">icepack package</a> &raquo;</li>
        
      <li>icepack.inverse module</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/icepack.inverse.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-icepack.inverse">
<span id="icepack-inverse-module"></span><h1>icepack.inverse module<a class="headerlink" href="#module-icepack.inverse" title="Permalink to this headline">¶</a></h1>
<p>Solvers for inverse problems</p>
<p>This module contains objects for specifying and solving inverse problems, where
some unobservable field is estimated based on observations of an observable
field and a physical model that connects the two. The class <cite>InverseProblem</cite> is
used to specify the problem to be solved, while the classes that inherit from
<cite>InverseSolver</cite> are used to solve it.</p>
<dl class="class">
<dt id="icepack.inverse.BFGSSolver">
<em class="property">class </em><code class="descclassname">icepack.inverse.</code><code class="descname">BFGSSolver</code><span class="sig-paren">(</span><em>problem</em>, <em>callback=&lt;function BFGSSolver.&lt;lambda&gt;&gt;</em>, <em>memory=5</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/icepack/inverse.html#BFGSSolver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icepack.inverse.BFGSSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#icepack.inverse.InverseSolver" title="icepack.inverse.InverseSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">icepack.inverse.InverseSolver</span></code></a></p>
<p>Implementation of <cite>InverseSolver</cite> using the limited-memory BFGS method
to compute a search direction</p>
<p>This implementation of inverse solvers uses a search direction based on the
last <cite>m</cite> values of the parameter and objective gradient to construct a low-
rank approximation to the inverse of the Hessian of the objective. The
resulting iteration exhibits superlinear convergence, while the search
direction is only marginally more expensive to compute than the steepest
descent direction.</p>
<p>See chapters 6-7 of Nocedal and Wright, Numerical Optimization, 2nd ed.</p>
<dl class="attribute">
<dt id="icepack.inverse.BFGSSolver.memory">
<code class="descname">memory</code><a class="headerlink" href="#icepack.inverse.BFGSSolver.memory" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of previous iterations used to construct the low-
rank approximation to the Hessian</p>
</dd></dl>

<dl class="method">
<dt id="icepack.inverse.BFGSSolver.update_search_direction">
<code class="descname">update_search_direction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/icepack/inverse.html#BFGSSolver.update_search_direction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icepack.inverse.BFGSSolver.update_search_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the low-rank approximation of the Hessian inverse</p>
<p>This procedure implements the two-loop recursion algorithm to apply the
low-rank approximation of the Hessian inverse to the derivative of the
objective functional. See Nocedal and Wright, Numerical Optimization,
2nd ed., algorithm 7.4.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="icepack.inverse.GaussNewtonSolver">
<em class="property">class </em><code class="descclassname">icepack.inverse.</code><code class="descname">GaussNewtonSolver</code><span class="sig-paren">(</span><em>problem</em>, <em>callback=&lt;function GaussNewtonSolver.&lt;lambda&gt;&gt;</em>, <em>search_tolerance=0.001</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/icepack/inverse.html#GaussNewtonSolver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icepack.inverse.GaussNewtonSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#icepack.inverse.InverseSolver" title="icepack.inverse.InverseSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">icepack.inverse.InverseSolver</span></code></a></p>
<p>Implementation of <cite>InverseSolver</cite> using an approximation to the Hessian
of the objective functional to approach Newton-like efficiency</p>
<p>This implementation of inverse solvers uses the search direction</p>
<div class="math notranslate nohighlight">
\[q = -H^{-1}dJ\]</div>
<p>where <span class="math notranslate nohighlight">\(H\)</span> is the Gauss-Newton approximation to the Hessian of the
objective functional. If <span class="math notranslate nohighlight">\(E\)</span> is the model-data misfit, <span class="math notranslate nohighlight">\(R\)</span> is
the regularization, and <span class="math notranslate nohighlight">\(G\)</span> is the linearization of the parameter-to-
observation map, then the Gauss-Newton matrix is</p>
<div class="math notranslate nohighlight">
\[H = dG^*\cdot d^2E\cdot dG + d^2R.\]</div>
<p>This matrix consists of only those terms in the Hessian of the full
objective functional that are of “first order”, i.e. any terms involving
<span class="math notranslate nohighlight">\(d^2G\)</span> are dropped. This search direction is more expensive to solve
for than in, say, gradient descent. However, it is almost always properly
scaled to the dimensions of the problem and converges in far fewer
iterations.</p>
<dl class="method">
<dt id="icepack.inverse.GaussNewtonSolver.gauss_newton_energy_norm">
<code class="descname">gauss_newton_energy_norm</code><span class="sig-paren">(</span><em>q</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/icepack/inverse.html#GaussNewtonSolver.gauss_newton_energy_norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icepack.inverse.GaussNewtonSolver.gauss_newton_energy_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the energy norm of a field w.r.t. the Gauss-Newton operator</p>
<p>The energy norm of a field <span class="math notranslate nohighlight">\(q\)</span> w.r.t. the Gauss-Newton operator
<span class="math notranslate nohighlight">\(H\)</span> can be computed using one fewer linear solve than if we were
to calculate the action of <span class="math notranslate nohighlight">\(H\cdot q\)</span> on <span class="math notranslate nohighlight">\(q\)</span>. This saves
computation when using the conjugate gradient method to solve for the
search direction.</p>
</dd></dl>

<dl class="method">
<dt id="icepack.inverse.GaussNewtonSolver.gauss_newton_mult">
<code class="descname">gauss_newton_mult</code><span class="sig-paren">(</span><em>q</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/icepack/inverse.html#GaussNewtonSolver.gauss_newton_mult"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icepack.inverse.GaussNewtonSolver.gauss_newton_mult" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a field by the Gauss-Newton operator</p>
</dd></dl>

<dl class="method">
<dt id="icepack.inverse.GaussNewtonSolver.update_search_direction">
<code class="descname">update_search_direction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/icepack/inverse.html#GaussNewtonSolver.update_search_direction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icepack.inverse.GaussNewtonSolver.update_search_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the Gauss-Newton system for the new search direction using the
preconditioned conjugate gradient method</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="icepack.inverse.GradientDescentSolver">
<em class="property">class </em><code class="descclassname">icepack.inverse.</code><code class="descname">GradientDescentSolver</code><span class="sig-paren">(</span><em>problem</em>, <em>callback=&lt;function GradientDescentSolver.&lt;lambda&gt;&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/icepack/inverse.html#GradientDescentSolver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icepack.inverse.GradientDescentSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#icepack.inverse.InverseSolver" title="icepack.inverse.InverseSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">icepack.inverse.InverseSolver</span></code></a></p>
<p>Implementation of <cite>InverseSolver</cite> using the objective function gradient
directly for a search direction</p>
<p>This implementation of inverse solvers uses the search direction</p>
<div class="math notranslate nohighlight">
\[q = -M^{-1}dJ\]</div>
<p>where <span class="math notranslate nohighlight">\(M\)</span> is the finite element mass matrix and <span class="math notranslate nohighlight">\(dJ\)</span> is the
gradient of the objective functional. The search direction is easy to
compute using this method, but is often poorly scaled, resulting in more
expensive bracketing and line search phases.</p>
<dl class="method">
<dt id="icepack.inverse.GradientDescentSolver.update_search_direction">
<code class="descname">update_search_direction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/icepack/inverse.html#GradientDescentSolver.update_search_direction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icepack.inverse.GradientDescentSolver.update_search_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the search direction to be the inverse of the mass matrix times
the gradient of the objective</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="icepack.inverse.InverseProblem">
<em class="property">class </em><code class="descclassname">icepack.inverse.</code><code class="descname">InverseProblem</code><span class="sig-paren">(</span><em>model</em>, <em>method</em>, <em>objective</em>, <em>regularization</em>, <em>state_name</em>, <em>state</em>, <em>parameter_name</em>, <em>parameter</em>, <em>model_args={}</em>, <em>dirichlet_ids=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/icepack/inverse.html#InverseProblem"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icepack.inverse.InverseProblem" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Specifies an inverse problem</p>
<p>This object is used to specify an inverse problem, i.e. estimating a
parameter <span class="math notranslate nohighlight">\(p\)</span> from measurements of a field <span class="math notranslate nohighlight">\(u\)</span>, where the two
are linked by some model physics. It consists mainly of a description of
the physics model, the model-data misfit and regularization functionals,
the initial state and parameters, and any auxiliary data such as extra
fields or boundary conditions.</p>
<p>This object merely specifies what problem to solve, not how to solve it.
That functionality is contained in the class <cite>InverseSolver</cite> and the
classes that inherit from it, such as <cite>GradientDescentSolver</cite> and
<cite>GaussNewtonSolver</cite>.</p>
<p>At present, this class assumes that the model physics are an elliptic
PDE that arises from an action principle. It is not equipped to deal
with, say, the mass conservation equation, which is hyperbolic.</p>
</dd></dl>

<dl class="class">
<dt id="icepack.inverse.InverseSolver">
<em class="property">class </em><code class="descclassname">icepack.inverse.</code><code class="descname">InverseSolver</code><a class="reference internal" href="_modules/icepack/inverse.html#InverseSolver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icepack.inverse.InverseSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base class for approximating the solution of an inverse problem</p>
<p>This object stores most of the data needed to iteratively optimize the
value of some parameter of a model, such as the rheology or friction of a
glacier, to match remote sensing observations. The key variables that need
to be stored are the current guess for the parameter, the observable state
computed from that parameter, the adjoint state, and the search direction.</p>
<p>The optimization problem is solved using a line search method; at each step
the parameter <span class="math notranslate nohighlight">\(p_k\)</span> is updated by finding a value <span class="math notranslate nohighlight">\(\alpha_k\)</span>
such that</p>
<div class="math notranslate nohighlight">
\[p_{k + 1} = p_k + \alpha_k\cdot q_k\]</div>
<p>reduces the value of the objective function, where <span class="math notranslate nohighlight">\(q_k\)</span> is the
search direction. This object implements most of the procedures necessary
for keeping the parameter, state, and adjoint consistent. Objects that
inherit from this one only need to define how the search direction is
computed.</p>
<dl class="attribute">
<dt id="icepack.inverse.InverseSolver.adjoint_state">
<code class="descname">adjoint_state</code><a class="headerlink" href="#icepack.inverse.InverseSolver.adjoint_state" title="Permalink to this definition">¶</a></dt>
<dd><p>The adjoint state variable computed from the current value of
the parameters and the primal state</p>
</dd></dl>

<dl class="attribute">
<dt id="icepack.inverse.InverseSolver.gradient">
<code class="descname">gradient</code><a class="headerlink" href="#icepack.inverse.InverseSolver.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>The derivative of the Lagrangian (objective + regularization +
physics constraints) with respect to the parameter</p>
</dd></dl>

<dl class="method">
<dt id="icepack.inverse.InverseSolver.line_search">
<code class="descname">line_search</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/icepack/inverse.html#InverseSolver.line_search"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icepack.inverse.InverseSolver.line_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a line search along the descent direction to get a new
value of the parameter</p>
</dd></dl>

<dl class="attribute">
<dt id="icepack.inverse.InverseSolver.objective">
<code class="descname">objective</code><a class="headerlink" href="#icepack.inverse.InverseSolver.objective" title="Permalink to this definition">¶</a></dt>
<dd><p>The functional of the state variable that we’re minimizing</p>
</dd></dl>

<dl class="attribute">
<dt id="icepack.inverse.InverseSolver.parameter">
<code class="descname">parameter</code><a class="headerlink" href="#icepack.inverse.InverseSolver.parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>The current value of the parameter we’re estimating</p>
</dd></dl>

<dl class="attribute">
<dt id="icepack.inverse.InverseSolver.problem">
<code class="descname">problem</code><a class="headerlink" href="#icepack.inverse.InverseSolver.problem" title="Permalink to this definition">¶</a></dt>
<dd><p>The instance of the inverse problem we’re solving</p>
</dd></dl>

<dl class="attribute">
<dt id="icepack.inverse.InverseSolver.regularization">
<code class="descname">regularization</code><a class="headerlink" href="#icepack.inverse.InverseSolver.regularization" title="Permalink to this definition">¶</a></dt>
<dd><p>The regularization functional, which penalizes unphysical modes
in the inferred parameter</p>
</dd></dl>

<dl class="attribute">
<dt id="icepack.inverse.InverseSolver.search_direction">
<code class="descname">search_direction</code><a class="headerlink" href="#icepack.inverse.InverseSolver.search_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the direction along which we’ll search for a new value of
the parameters</p>
</dd></dl>

<dl class="method">
<dt id="icepack.inverse.InverseSolver.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em>atol=0.0</em>, <em>rtol=1e-06</em>, <em>max_iterations=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/icepack/inverse.html#InverseSolver.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icepack.inverse.InverseSolver.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for a new value of the parameters, stopping once either
the objective functional gets below a threshold value or stops
improving.</p>
</dd></dl>

<dl class="attribute">
<dt id="icepack.inverse.InverseSolver.state">
<code class="descname">state</code><a class="headerlink" href="#icepack.inverse.InverseSolver.state" title="Permalink to this definition">¶</a></dt>
<dd><p>The state variable computed from the current value of the
parameter</p>
</dd></dl>

<dl class="method">
<dt id="icepack.inverse.InverseSolver.step">
<code class="descname">step</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/icepack/inverse.html#InverseSolver.step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icepack.inverse.InverseSolver.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a line search along the current descent direction to get
a new value of the parameters, then compute the new state, adjoint,
and descent direction.</p>
</dd></dl>

<dl class="method">
<dt id="icepack.inverse.InverseSolver.update_adjoint_state">
<code class="descname">update_adjoint_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/icepack/inverse.html#InverseSolver.update_adjoint_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icepack.inverse.InverseSolver.update_adjoint_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the adjoint state for new values of the observable state and
parameters so that we can calculate derivatives</p>
</dd></dl>

<dl class="method">
<dt id="icepack.inverse.InverseSolver.update_state">
<code class="descname">update_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/icepack/inverse.html#InverseSolver.update_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icepack.inverse.InverseSolver.update_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the observable state for a new value of the parameters</p>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="icepack.norms.html" class="btn btn-neutral float-right" title="icepack.norms module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="icepack.interpolate.html" class="btn btn-neutral" title="icepack.interpolate module" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Daniel Shapero.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.0.3',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>